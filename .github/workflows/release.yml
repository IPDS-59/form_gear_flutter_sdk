name: Release Workflow - Tag, Deploy & Back-merge

on:
  pull_request:
    branches: [main]
    types: [closed]

env:
  FLUTTER_VERSION: '3.35.3'

jobs:
  release-process:
    if: github.event.pull_request.merged == true && (startsWith(github.head_ref, 'release/') || startsWith(github.head_ref, 'hotfix/'))
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      actions: write

    steps:
      - name: Checkout main branch
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0
          token: ${{ secrets.PAT_TOKEN }}

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Extract version from branch name
        id: version
        run: |
          BRANCH_NAME="${{ github.event.pull_request.head.ref }}"
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT

          if [[ $BRANCH_NAME == release/* ]]; then
            VERSION=$(echo $BRANCH_NAME | sed 's/release\///')
            TYPE="release"
            BASE_BRANCH="develop"
          elif [[ $BRANCH_NAME == hotfix/* ]]; then
            VERSION=$(echo $BRANCH_NAME | sed 's/hotfix\///')
            TYPE="hotfix"
            BASE_BRANCH="main"
          fi

          # Ensure version starts with 'v'
          if [[ ! $VERSION == v* ]]; then
            VERSION="v$VERSION"
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "type=$TYPE" >> $GITHUB_OUTPUT
          echo "base_branch=$BASE_BRANCH" >> $GITHUB_OUTPUT
          echo "clean_version=$(echo $VERSION | sed 's/^v//')" >> $GITHUB_OUTPUT

      # STEP 1: CREATE TAG AND PREPARE RELEASE
      - name: Check if tag already exists
        id: check_tag
        run: |
          VERSION="${{ steps.version.outputs.version }}"

          if git tag -l | grep -q "^${VERSION}$"; then
            echo "tag_exists=true" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  Tag $VERSION already exists"
          else
            echo "tag_exists=false" >> $GITHUB_OUTPUT
            echo "‚úÖ Tag $VERSION does not exist, will create"
          fi

      - name: Setup Flutter
        if: steps.check_tag.outputs.tag_exists == 'false'
        uses: subosito/flutter-action@v2
        with:
          flutter-version: ${{ env.FLUTTER_VERSION }}
          cache: true

      - name: Get dependencies and validate
        if: steps.check_tag.outputs.tag_exists == 'false'
        run: |
          echo "üì¶ Installing dependencies..."
          flutter pub get

          echo "üîç Running static analysis..."
          flutter analyze lib/

          echo "üß™ Running tests..."
          if [ -d "test" ] && [ "$(find test -name '*_test.dart' | wc -l)" -gt 0 ]; then
            flutter test --coverage
          else
            echo "‚ö†Ô∏è No tests found, skipping test execution"
          fi

      - name: Get previous tag for changelog
        id: previous_tag
        run: |
          # Get the most recent tag before this one
          PREVIOUS_TAG=$(git tag --sort=-version:refname | head -n1 || echo "")
          echo "previous_tag=$PREVIOUS_TAG" >> $GITHUB_OUTPUT
          echo "Previous tag: $PREVIOUS_TAG"

          # Determine base commit for changelog
          if [ -n "$PREVIOUS_TAG" ]; then
            BASE_COMMIT="$PREVIOUS_TAG"
          else
            # If no tags exist, use first commit
            BASE_COMMIT=$(git rev-list --max-parents=0 HEAD)
          fi
          echo "base_commit=$BASE_COMMIT" >> $GITHUB_OUTPUT

      - name: Generate tag message and changelog
        id: tag_info
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          TYPE="${{ steps.version.outputs.type }}"
          PREVIOUS_TAG="${{ steps.previous_tag.outputs.previous_tag }}"
          BASE_COMMIT="${{ steps.previous_tag.outputs.base_commit }}"

          # Create tag message
          TAG_MESSAGE="$TYPE: $VERSION"
          echo "tag_message=$TAG_MESSAGE" >> $GITHUB_OUTPUT

          # Generate categorized changelog for tag annotation
          CHANGELOG_FILE="tag_changelog.txt"

          echo "$TYPE $VERSION" > $CHANGELOG_FILE
          echo "" >> $CHANGELOG_FILE
          echo "Merged PR: ${{ github.event.pull_request.html_url }}" >> $CHANGELOG_FILE
          echo "Merged by: @${{ github.event.pull_request.merged_by.login }}" >> $CHANGELOG_FILE
          echo "" >> $CHANGELOG_FILE

          if [ -n "$PREVIOUS_TAG" ]; then
            echo "Changes since $PREVIOUS_TAG:" >> $CHANGELOG_FILE
          else
            echo "Initial release changes:" >> $CHANGELOG_FILE
          fi
          echo "" >> $CHANGELOG_FILE

          # Enhanced categorization for Flutter/Dart projects with better pattern matching
          ALL_COMMITS=$(git log --pretty=format:"- %s (%h)" "$BASE_COMMIT..HEAD")

          echo "‚ú® Features:" >> $CHANGELOG_FILE
          FEATURE_COMMITS=$(echo "$ALL_COMMITS" | grep -E "^- (feat|feature)(\([^)]*\))?:" | head -10 || echo "")
          if [ -n "$FEATURE_COMMITS" ]; then
            echo "$FEATURE_COMMITS" >> $CHANGELOG_FILE
          fi
          echo "" >> $CHANGELOG_FILE

          echo "üêõ Bug Fixes:" >> $CHANGELOG_FILE
          BUG_COMMITS=$(echo "$ALL_COMMITS" | grep -E "^- (fix|bugfix)(\([^)]*\))?:" | head -10 || echo "")
          if [ -n "$BUG_COMMITS" ]; then
            echo "$BUG_COMMITS" >> $CHANGELOG_FILE
          fi
          echo "" >> $CHANGELOG_FILE

          echo "üì± Platform Updates:" >> $CHANGELOG_FILE
          PLATFORM_COMMITS=$(echo "$ALL_COMMITS" | grep -E "^- (android|ios|platform|refactor\((android|ios)\)):" | head -5 || echo "")
          if [ -n "$PLATFORM_COMMITS" ]; then
            echo "$PLATFORM_COMMITS" >> $CHANGELOG_FILE
          fi
          echo "" >> $CHANGELOG_FILE

          echo "üìö Documentation:" >> $CHANGELOG_FILE
          DOC_COMMITS=$(echo "$ALL_COMMITS" | grep -E "^- (docs?|doc)(\([^)]*\))?:" | head -5 || echo "")
          if [ -n "$DOC_COMMITS" ]; then
            echo "$DOC_COMMITS" >> $CHANGELOG_FILE
          fi
          echo "" >> $CHANGELOG_FILE

          echo "üîß Maintenance:" >> $CHANGELOG_FILE
          MAINTENANCE_COMMITS=$(echo "$ALL_COMMITS" | grep -E "^- (chore|refactor|perf|style|test)(\([^)]*\))?:" | grep -v "^- refactor\((android|ios)\):" | head -10 || echo "")
          if [ -n "$MAINTENANCE_COMMITS" ]; then
            echo "$MAINTENANCE_COMMITS" >> $CHANGELOG_FILE
          fi
          echo "" >> $CHANGELOG_FILE

          # Check for breaking changes
          BREAKING_COMMITS=$(echo "$ALL_COMMITS" | grep -E "(BREAKING CHANGE|!:|feat!:|fix!:)" || echo "")

          if [ -n "$BREAKING_COMMITS" ]; then
            echo "‚ö†Ô∏è Breaking Changes:" >> $CHANGELOG_FILE
            echo "$BREAKING_COMMITS" | head -5 >> $CHANGELOG_FILE
          else
            echo "‚úÖ No Breaking Changes" >> $CHANGELOG_FILE
          fi
          echo "" >> $CHANGELOG_FILE

          echo "üéØ Key Highlights:" >> $CHANGELOG_FILE
          # Generate intelligent highlights based on commit content
          if echo "$ALL_COMMITS" | grep -q "interceptor\|alice\|di\|dependency"; then
            echo "- Enhanced HTTP interceptor and dependency injection support" >> $CHANGELOG_FILE
          fi
          if echo "$ALL_COMMITS" | grep -q "realm.*name\|realmName\|custom.*realm"; then
            echo "- Added custom realm names configuration support" >> $CHANGELOG_FILE
          fi
          if echo "$ALL_COMMITS" | grep -q "sdk.*info\|expose.*sdk"; then
            echo "- Exposed SDK version and metadata information" >> $CHANGELOG_FILE
          fi
          if echo "$ALL_COMMITS" | grep -q "configuration.*screen\|config.*screen"; then
            echo "- Enhanced configuration screen with improved UX" >> $CHANGELOG_FILE
          fi
          echo "" >> $CHANGELOG_FILE
          echo "üì¶ Package available on pub.dev after release." >> $CHANGELOG_FILE

          echo "changelog_file=$CHANGELOG_FILE" >> $GITHUB_OUTPUT

      - name: Update pubspec.yaml version
        if: steps.check_tag.outputs.tag_exists == 'false'
        run: |
          CLEAN_VERSION="${{ steps.version.outputs.clean_version }}"
          echo "üìù Updating pubspec.yaml version to $CLEAN_VERSION..."

          # Update version in pubspec.yaml
          sed -i.bak "s/^version: .*/version: $CLEAN_VERSION/" pubspec.yaml

          # Verify the change
          echo "‚úÖ Updated version in pubspec.yaml:"
          grep "^version:" pubspec.yaml

          # Stage the change
          git add pubspec.yaml

      - name: Create and push tag
        if: steps.check_tag.outputs.tag_exists == 'false'
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          TAG_MESSAGE="${{ steps.tag_info.outputs.tag_message }}"
          CHANGELOG_FILE="${{ steps.tag_info.outputs.changelog_file }}"

          echo "üè∑Ô∏è  Creating annotated tag $VERSION..."

          # Commit version update if there are changes
          if ! git diff --cached --quiet; then
            git commit -m "chore: bump version to ${{ steps.version.outputs.clean_version }}"
          fi

          # Create annotated tag with changelog
          git tag -a "$VERSION" -F "$CHANGELOG_FILE"

          # Push the tag
          git push origin "$VERSION"

          echo "‚úÖ Tag $VERSION created and pushed successfully"
          echo "üöÄ Publish workflow will be triggered automatically by tag push"

      # STEP 2: CLEANUP MERGED BRANCH
      - name: Delete merged release/hotfix branch
        env:
          GH_TOKEN: ${{ secrets.PAT_TOKEN }}
        run: |
          BRANCH_NAME="${{ steps.version.outputs.branch_name }}"

          echo "üßπ Cleaning up merged branch: $BRANCH_NAME"

          # Delete the remote branch
          git push origin --delete "$BRANCH_NAME" || echo "‚ö†Ô∏è  Branch $BRANCH_NAME may have already been deleted"

          echo "‚úÖ Branch cleanup completed"

      # STEP 3: UPDATE ORIGINAL PR WITH STATUS
      - name: Comment on original PR with status
        env:
          GH_TOKEN: ${{ secrets.PAT_TOKEN }}
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          TYPE="${{ steps.version.outputs.type }}"
          PR_NUMBER="${{ github.event.pull_request.number }}"
          BRANCH_NAME="${{ steps.version.outputs.branch_name }}"

          if [[ "${{ steps.check_tag.outputs.tag_exists }}" == "true" ]]; then
            gh pr comment $PR_NUMBER --body "üîÑ **Release Process Completed (Tag Existed)**

            The complete Git Flow release process has finished:

            ## ‚úÖ Completed Actions
            - **Tag**: \`$VERSION\` ‚ö†Ô∏è (already existed - no new publish triggered)
            - **Type**: $TYPE
            - **Branch**: \`$BRANCH_NAME\` üßπ (deleted)
            - **Back-merge**: ‚è≥ [Separate workflow will handle develop sync](${{ github.server_url }}/${{ github.repository }}/actions)

            ## ‚ö†Ô∏è Note
            Since the tag already existed, no new publish workflow was triggered. If you need to republish, delete and recreate the tag or manually trigger the publish workflow.

            ## üéâ Git Flow Complete
            Your release branch has been merged and cleaned up. The back-merge workflow will automatically handle syncing develop."
          else
            gh pr comment $PR_NUMBER --body "üöÄ **Release Process Completed Successfully**

            The complete Git Flow release process has finished:

            ## ‚úÖ Completed Actions
            - **Tag**: [\`$VERSION\`](${{ github.server_url }}/${{ github.repository }}/releases/tag/$VERSION) ‚úÖ (created & published)
            - **Type**: $TYPE
            - **Branch**: \`$BRANCH_NAME\` üßπ (deleted)
            - **Back-merge**: ‚è≥ [Separate workflow will handle develop sync](${{ github.server_url }}/${{ github.repository }}/actions)
            - **Publish**: üöÄ [Workflow triggered automatically](${{ github.server_url }}/${{ github.repository }}/actions)

            ## üì¶ Package Publishing
            The publish workflow will automatically:
            - Validate and test the package
            - Create GitHub release with assets
            - Perform dry run for pub.dev (manual publish available)

            ## üéâ Git Flow Complete
            Your release tag has been created and publish workflow triggered! Monitor the publish progress and the back-merge workflow will sync develop."
          fi

      - name: Create workflow summary
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          TYPE="${{ steps.version.outputs.type }}"
          BRANCH_NAME="${{ steps.version.outputs.branch_name }}"

          echo "## üöÄ Release Workflow Completed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version**: \`$VERSION\`" >> $GITHUB_STEP_SUMMARY
          echo "**Type**: $TYPE" >> $GITHUB_STEP_SUMMARY
          echo "**Original Branch**: \`$BRANCH_NAME\` (cleaned up)" >> $GITHUB_STEP_SUMMARY
          echo "**Merge Commit**: \`${{ github.event.pull_request.merge_commit_sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ‚úÖ Completed Actions" >> $GITHUB_STEP_SUMMARY

          if [[ "${{ steps.check_tag.outputs.tag_exists }}" == "true" ]]; then
            echo "- ‚ö†Ô∏è  Tag \`$VERSION\` already existed (no publish triggered)" >> $GITHUB_STEP_SUMMARY
          else
            echo "- üè∑Ô∏è Created and pushed tag \`$VERSION\`" >> $GITHUB_STEP_SUMMARY
            echo "- üöÄ Triggered publish workflow automatically" >> $GITHUB_STEP_SUMMARY
            echo "- üìù Updated pubspec.yaml version" >> $GITHUB_STEP_SUMMARY
          fi

          echo "- ‚è≥ Back-merge workflow will handle develop sync" >> $GITHUB_STEP_SUMMARY
          echo "- üßπ Deleted merged branch \`$BRANCH_NAME\`" >> $GITHUB_STEP_SUMMARY
          echo "- üí¨ Updated original PR with status" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üîó Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "1. üöÄ [Monitor publish workflow progress](${{ github.server_url }}/${{ github.repository }}/actions)" >> $GITHUB_STEP_SUMMARY
          echo "2. ‚è≥ Monitor back-merge workflow for develop sync" >> $GITHUB_STEP_SUMMARY
          echo "3. üì¶ Manually publish to pub.dev using publish workflow if desired" >> $GITHUB_STEP_SUMMARY
          echo "4. üéâ Release process complete!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üîó Important Links" >> $GITHUB_STEP_SUMMARY
          echo "- [Publish Workflow](${{ github.server_url }}/${{ github.repository }}/actions/workflows/publish.yml)" >> $GITHUB_STEP_SUMMARY
          echo "- [Back-merge Workflow](${{ github.server_url }}/${{ github.repository }}/actions/workflows/back-merge.yml)" >> $GITHUB_STEP_SUMMARY

  handle-failure:
    if: failure() && github.event.pull_request.merged == true && (startsWith(github.head_ref, 'release/') || startsWith(github.head_ref, 'hotfix/'))
    needs: release-process
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write

    steps:
      - name: Comment on PR about failure
        env:
          GH_TOKEN: ${{ secrets.PAT_TOKEN }}
        run: |
          BRANCH_NAME="${{ github.event.pull_request.head.ref }}"
          PR_NUMBER="${{ github.event.pull_request.number }}"

          if [[ $BRANCH_NAME == release/* ]]; then
            VERSION=$(echo $BRANCH_NAME | sed 's/release\///')
            TYPE="release"
          elif [[ $BRANCH_NAME == hotfix/* ]]; then
            VERSION=$(echo $BRANCH_NAME | sed 's/hotfix\///')
            TYPE="hotfix"
          fi

          # Ensure version starts with 'v'
          if [[ ! $VERSION == v* ]]; then
            VERSION="v$VERSION"
          fi

          gh pr comment $PR_NUMBER --body "‚ùå **Release Workflow Failed**

          The automatic release workflow failed during processing.

          **Expected Actions:**
          - üè∑Ô∏è Create tag \`$VERSION\`
          - üì¶ Create GitHub Release
          - ‚è≥ Trigger back-merge workflow
          - üßπ Clean up branch \`$BRANCH_NAME\`

          **Manual Recovery Steps:**
          1. **Create tag manually:**
             \`\`\`bash
             git checkout main
             git pull origin main
             git tag -a \"$VERSION\" -m \"$TYPE: $VERSION\"
             git push origin \"$VERSION\"
             \`\`\`

          2. **Create GitHub Release:**
             \`\`\`bash
             gh release create \"$VERSION\" --title \"üöÄ $VERSION\" --target main
             \`\`\`

          3. **Trigger back-merge manually:**
             \`\`\`bash
             # The back-merge workflow should trigger automatically
             # If not, check the Actions tab for back-merge workflow
             \`\`\`

          4. **Clean up branch:**
             \`\`\`bash
             git push origin --delete \"$BRANCH_NAME\"
             \`\`\`

          **Status**: ‚ùå Failed - manual intervention required"
            